# コイン問題 動的計画法
# 額面がc1,c2,...cm円のm種類のコインを使って、n円を支払うときの、コインの最小枚数
# (各額面のコインは何度でも使用することが出来る)
# 入力
#   n m <= 1<=n<=50_000, 1<=m<=20
#   c1 c2 .. cm 1<=c<=10_000,額面は全て異なり、必ず1を含む
# 入力例
#   15 6
#   1 2 7 8 12 50
# 出力例
#   2
# 解説
# 仮にコインの額面が1,5,10,50,100,500と決められていれば、与えられた額n円に対して、
# 額面の大きいものから引いて(割って)いけば、最小の枚数を求めることが出来る。
# その時点で最適の買いを選んでいくアルゴリズムを貪欲法(greedy method)という。
# 一方、使用できる額面によっては貪欲法では正しく解がでない。
# =>動的計画法では最適解を求めることが出来る。
#   c[m]: c[i]をi番目のコインの額面とする配列
#   t[m][n+1]: T[i][j]をi番目までのコインを使ってj円支払うときのコインの最小枚数とする2次元配列
#   としたとき、t[i][j] = min(t[i-1][j], t[i][j-c[j]+1])で求められる。
#   (i番目のコインを使わない場合の枚数 or i番目のコインを使い、i番目のコインの金額を引いたj番目の数に1を足した数)
#   さらにいうと、コインの額面ごとに最適枚数を記録しておく必要はないため、j円支払うときのコインの枚数は1次元配列t[j]を用いれば良い。
#   => t[j] = min(t[j], t[j-c[i]+1])

n,m = gets.split.map &:to_i
cm = gets.split.map &:to_i

def cm.get_the_number_of_coin(n)
  t = Array.new(n+1, Float::INFINITY)
  t[0] = 0

  self.each_with_index do |c, i|
    for j in c..n
      t[j] = [t[j], t[j-c]+1].min
    end
  end
  t[n]
end

puts cm.get_the_number_of_coin(n)
